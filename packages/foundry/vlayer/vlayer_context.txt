How it works?
vlayer introduces new super powers to Solidity smart contracts:

Time Travel: Execute a smart contract on historical data.
Teleport: Execute a smart contract across different blockchain networks.
Web proof: Access verified web content, including APIs and websites.
Email proof: Access verified email content.
Prover and Verifier
To implement the above features, vlayer introduces two new contract types: Prover and Verifier.

The Prover code runs on the vlayer zkEVM infrastructure. Proof data structure is the result of this operation.

The Verifier verifies generated proof and runs your code on EVM-compatible chains.

Both types of contracts are developed using the Solidity programming language.

vlayer contract execution
A typical vlayer execution flow has three steps:

The application initiates a call to the Prover contract that is executed off-chain in the zkEVM. All the input for this call is private by default and is not published on-chain.
The result of the computation is passed along with a proof to be executed in the on-chain contract. All the output returned from Prover contract is public and is published on-chain as parameters to the Verifier contract.
The Verifier contract verifies the data sent by the proving party (using the submitted proof by client) and then executes the Verifier code.
See the diagram below.

Off-chain execution simplified diagram The flow of vlayer contract execution

Prover
vlayer Prover contracts have a few distinct properties:

verifiability - can be executed off-chain and results can't be forged.
privacy - inputs are private by default and are not published on-chain.
no gas fees - no usual transaction size limits apply.
All arguments passed to the Prover contract functions are private by default. To make an argument public, simply add it to the list of returned values.

See the example Prover contract code below. It generates proof of ownership of the BYAC (Bored Ape Yacht Club) NFT.

contract BoredApeOwnership is Prover  {
    function main(address _owner, uint256 _apeId) public returns (Proof, address) {  
      // jumps to block 12292922 at ETH mainnet (chainId=1), when BYAC where minted
      setChainId(1, 12292922); 

      require(IERC721(BYAC_NFT_ADDR).ownerOf(_apeId) == _owner, "Given address not owning that BYAC");

      return (proof(), _owner); 
    }
}
In order to access Prover specific features, your contract needs to derive from the vlayer Prover contract. Then setChainId() teleport context to a historic block at Ethereum Mainnet (chainId=1) in which the first mint of BYAC NFT occurred. require makes sure that the given address (_owner) was the owner of the specific _apeId at that point of time. The owner address, which makes it public input for the Verifier contract.

Verifier
The Verifier smart contract validates the correctness of a computation generated by Prover, without revealing the underlying information. Such contracts can be used to facilitate more complex workflows, such as privacy-preserving decentralized finance (DeFi) applications or confidential voting systems.

Verification logic is immutable once deployed on the blockchain, ensuring consistent and permissionless access.

See the example Verifer contract below. It transfers tokens to proven owner of certain NFT:

contract Airdrop is Verifier {
  function claim(Proof calldata _p, address owner) 
    public 
    onlyVerified(PROVER_VLAYER_CONTRACT_ADDR, NftOwnership.main.selector) 
  {
    IERC20(TOKEN_ADDR).transfer(owner, 1000);
  }
}
Note that the above contract inherits from the Verfier vlayer contract. It is necessary for veryfing the computation done by the Prover contract from the previous step.

claim() function takes proof returned by the vlayer SDK as the first argument. Other arguments are public inputs returned from Prover main() function (in the same order).

onlyVerified(address, bytes4) modifier ensures that proof is valid and takes two arguments:

Address of the Prover contract
Function selector of the Prover main function
Proof doesn't have to be passed to onlyVerified as an argument. However, it has to be passed as an argument to function that is being decorated with onlyVerified, along with the public outputs.

To learn more about how the Prover and Verifier work under the hood, please refer to our Advanced section.


Web
Existing web applications including finance, social media, government, ecommerce and many other types of services contain valuable information and can be turned into great data sources.

With vlayer, you can leverage this data in smart contracts.

Web Proofs
Web Proofs provide cryptographic proof of web data served by any HTTPS server, allowing developers to use this data in smart contracts. Only a small subset of the required data is published on-chain.

Web Proofs ensure that the data received has not been tampered with. Without Web Proofs, proving this on-chain is difficult, especially when aiming for an automated and trusted solution.

Example Prover
Let's say we want to mint an NFT for a wallet address linked to a specific X/Twitter handle.

Hereâ€™s a sample Prover contract:

import {Strings} from "@openzeppelin-contracts/utils/Strings.sol";
import {Proof} from "vlayer-0.1.0/Proof.sol";
import {Prover} from "vlayer-0.1.0/Prover.sol";
import {Web, WebProof, WebProofLib, WebLib} from "vlayer-0.1.0/WebProof.sol";

contract WebProofProver is Prover {
    using Strings for string;
    using WebProofLib for WebProof;
    using WebLib for Web;

    string dataUrl = "https://api.x.com/1.1/account/settings.json";

    function main(WebProof calldata webProof, address account)
        public
        view
        returns (Proof memory, string memory, address)
    {
        Web memory web = webProof.verify(dataUrl);

        string memory screenName = web.jsonGetString("screen_name");

        return (proof(), screenName, account);
    }
}
What happens in the above code?

Setup the Prover contract:

WebProofProver inherits from the Prover contract, enabling off-chain proving of web data.
The main function receives a WebProof, which contains a signed transcript of an HTTPS session (see the chapter from JS section on how to obtain WebProof). The transcript is signed by a Notary (see Security Considerations section for details about the TLS Notary).
Verify the Web Proof:

The call to webProof.verify(dataUrl) does the following:

Verifies the HTTPS transcript.
Verifies the Notary's signature on the transcript.
Ensures the Notary is on the list of trusted notaries (via their signing key).
Confirms the data comes from the expected domain (api.x.com in this case).
Check whether the HTTPS data comes from the expected dataUrl. dataUrl is a URL Pattern against which the actual URL is checked.
Ensures that the server's SSL certificate and its chain of authority are verified.
Retrieves the plain text transcript for further processing.
Extract the relevant data:

web.jsonGetString("screen_name") extracts the screen_name from the JSON response.

Return the results:

If everything checks out, the function returns the proof placeholder, screenName, and the account.

If there are no errors and the proof is valid, the data is ready for on-chain verification.

Obtaining Web Proofs
vlayer provides two ways to obtain Web Proofs:

Client-side (via browser extension)
Server-side (via the vlayer CLI)
Client-side
The client-side method is intended for scenarios where the target data is authenticated using browser cookies (e.g., logged-in user sessions). It uses the vlayer browser extension to capture and notarize HTTP requests directly from the userâ€™s browsing context.

This approach is ideal for proving access to social media activity, personal or banking data, Web2 loyalty points, reputation scores, or any other cookie-protected content.

ðŸ’¡ Try it Now

To run an example that proves ownership of an X/Twitter handle on your computer, enter the following command in your terminal:

vlayer init --template simple-web-proof
This command will download all the necessary artifacts for your project.
The next steps are explained in the Running Examples and Quickstart Guide.

Server-side
The server-side method is intended for proving data retrieved from HTTP requests that are either public or authenticated via token. Itâ€™s a great fit for APIs such as AI models, fintech services, or any backend integration where browser cookie is not required.

ðŸ’¡ Try it Now

To run an example that proves data returned by the Kraken API, enter the following command in your terminal:

vlayer init --template kraken-web-proof
This will download all necessary artifacts to your project.
The next steps are detailed in Running Examples.

Example Verifier
The contract below verifies provided Web Proof and mints a unique NFT for the Twitter/X handle ownerâ€™s wallet address.

import {WebProofProver} from "./WebProofProver.sol";
import {Proof} from "vlayer/Proof.sol";
import {Verifier} from "vlayer/Verifier.sol";

import {ERC721} from "@openzeppelin-contracts/token/ERC721/ERC721.sol";

contract WebProofVerifier is Verifier, ERC721 {
    address public prover;

    constructor(address _prover) ERC721("TwitterNFT", "TNFT") {
        prover = _prover;
    }

    function verify(Proof calldata, string memory username, address account)
        public
        onlyVerified(prover, WebProofProver.main.selector)
    {
        uint256 tokenId = uint256(keccak256(abi.encodePacked(username)));
        require(_ownerOf(tokenId) == address(0), "User has already minted a TwitterNFT");

        _safeMint(account, tokenId);
    }
}

Whatâ€™s happening here?

Set up the Verifier:

The prover variable stores the address of the Prover contract that generated the proof.
The WebProofProver.main.selector gets the selector for the WebProofProver.main() function.
WebProofVerifier inherits from Verifier to access the onlyVerified modifier, which ensures the proof is valid.
WebProofVerifier also inherits from ERC721 to support NFTs.
Verification checks:

The tokenId (a hash of the handle) must not already be minted.

Mint the NFT:

Once verified, a unique TwitterNFT is minted for the user.

And that's it!

As you can see, Web Proofs can be a powerful tool for building decentralized applications by allowing trusted off-chain data to interact with smart contracts.

Notary
A Notary is a third-party server that participates in a two-sided Transport Layer Security (TLS) session between a client and a server. Its role is to attest that specific communication has occurred between the two parties.

Security Considerations
The Web Proof feature is based on the TLSNotary protocol. Web data is retrieved from an HTTP endpoint and it's integrity and authenticity during the HTTP session is verified using the TLS protocol (the "S" in HTTPS), which secures most modern encrypted connections on the Internet. Web Proofs ensure the integrity and authenticity of web data after the HTTPS session finishes by extending the TLS protocol. Notary, joins the HTTPS session between the client and the server and can cryptographically certify its contents.

From privacy perspective, it is important to note that the Notary server never has access to the plaintext transcript of the connection and therefore, Notary can never steal client data and pretend to be client. Furthermore, the transcript can be redacted (i.e. certain parts can be removed) by the client, making these parts of the communication not accessible by Prover and vlayer infrastructure running the Prover.

Redaction
Trust Assumptions
It is important to understand that the Notary is a trusted party in the above setup. Since the Notary certifies the data, a malicious Notary could collude with a malicious client to create fake proofs that would still be successfully verified by Prover. Currently vlayer runs it's own Notary server, which means that vlayer needs to be trusted to certify HTTPS sessions.

Currently vlayer also needs to be trusted when passing additional data (data other than the Web Proof itself) to Prover smart contract, e.g. account in the example above. The Web Proof could be hijacked before running Prover and additional data, different from the original, could be passed to Prover, e.g. an attacker could pass their own address as account in our WebProofProver example. Before going to production this will be addressed by making the setup trustless through an association of the additional data with a particular Web Proof in a way that's impossible to forge.

vlayer will publish a roadmap outlining how it will achieve a high level of security when using the Notary service.


Server-side proving
vlayer supports generating Web Proofs on the server side. This method is especially useful for proving web data returned by public or token-authenticated APIs, without requiring a browser extension.

Typical use cases include verifying responses from centralized services such as Coinbase, Binance, Kraken, Stripe, Github, Meta, YouTube or similar platforms.

To notarize HTTP requests from the server, use the vlayer CLI:

vlayer web-proof-fetch [OPTIONS] --url <URL>
Available options:

      --url <URL>            Full URL of the request to notarize
      --host <HOST>          Optional host address, if different from the domain provided in URL
      --notary <NOTARY_URL>  Notary URL [default: https://test-notary.vlayer.xyz/]
  -H, --headers <HEADER>     Additional headers (format: "Header-Name: Header-Value")
  -d, --data <DATA>          HTTP data to be sent with the request
  -h, --help                 Print help
  -V, --version              Print version
Example usage:

vlayer web-proof-fetch 
  --notary "https://test-notary.vlayer.xyz" 
  --url "https://api.kraken.com/0/public/Ticker?pair=ETHUSD"
Such produced Web Proof (including url, headers and body) can be passed into vlayer prover and then verified on-chain.

ðŸ’¡ Try it Now

To run an example that proves data returned by the Kraken API, enter the following command in your terminal:

vlayer init --template kraken-web-proof
This will download all necessary artifacts to your project.
The next steps are detailed in Running Examples.

For proving HTTP requests that rely on httpOnly cookies, use the client-side approach.